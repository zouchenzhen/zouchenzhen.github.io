<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b0b0d" />
  <title>Love Board Â· Triple Heartbeat + LongPress</title>
  <style>
    html, body {
      height: 100%; margin: 0; background:#0b0b0d; color:#fff; overflow: hidden;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans",
        "PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Arial,
        "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif;
    }
    #stage {
      position: fixed; inset:0; width:100%; height:100%; display:block;
      touch-action: manipulation; -webkit-tap-highlight-color: transparent;
    }
    .hint { position:fixed; left:12px; bottom:12px; font-size:12px; color:#a4a4aa; opacity:.75; user-select:none; pointer-events:none;}
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div class="hint">ç‚¹å‡»/è§¦æ‘¸ï¼šå¿ƒå½¢çˆ†è£‚ï¼›é•¿æŒ‰ï¼šè¿ç»­å¤šå±‚å¿ƒå½¢çˆ†è£‚</div>

  <script>
  ;(() => {
    /** ================= ä¸ªæ€§åŒ–é…ç½® ================= */
    const CONFIG = {
      loverName: "ğŸ’— é‚¹é‚¹ä¸éŸ©éŸ© ä¸€å‘¨å¹´å¿«ä¹ æˆ‘ä»¬å¤©ä¸‹ç¬¬ä¸€å¥½ æ°¸è¿œåœ¨ä¸€èµ· ğŸ’—",
      bgColor: "#0b0b0d",

      // é£˜åŠ¨æ–‡å­—ï¼ˆå‡åŠå­—å· + é€Ÿåº¦+50% + é˜²é‡å ï¼‰
      textCount: 22,
      textScales: [0.9, 1.0, 1.15],
      speed: 15,
      rotMax: 0.06,
      alphaRange: [0.55, 0.85],
      minDistanceFactor: 0.75,
      textColor: "#ffd1e2",

      // ä¸­å¿ƒä¸‰å±‚å¤§çˆ±å¿ƒï¼ˆç”±å°çˆ±å¿ƒæ‹¼æˆï¼‰
      bigHeart: {
        baseScaleFactor: 0.010,
        freq: 1.05,     // å¿ƒè·³é¢‘ç‡
        ampHi: 0.14,    // å¤§è·³æŒ¯å¹…
        ampLo: 0.06,    // å°è·³æŒ¯å¹…
        layers: [
          { scale: 0.86, count: 150, alpha: 0.75 },
          { scale: 1.00, count: 220, alpha: 0.92 },
          { scale: 1.16, count: 180, alpha: 0.60 }
        ],
        dotSizeMin: 10,
        dotSizeMax: 16,
        colors: ["#ff6ea6","#ff7fb0","#ff96bf","#ffc3d6"]
      },

      // è§¦æ‘¸/ç‚¹å‡»çˆ†è£‚ï¼ˆå¿ƒå½¢è½¨è¿¹ï¼‰
      burst: {
        count: 90,            // å•è½®é‡‡æ ·æ•°é‡
        velocity: 56,         // åˆé€Ÿåº¦
        life: 1.4,            // ç²’å­å¯¿å‘½
        scaleFactor: 0.003,   // è¿·ä½ å¿ƒå½¢ç›¸å¯¹å±å¹•çŸ­è¾¹æ¯”ä¾‹
        jitter: 2.0,          // ä½ç½®æŠ–åŠ¨
        // é•¿æŒ‰è¿å‘
        longpressIntervalMs: 120,  // æ¯æ¬¡å–·å‘é—´éš”
        longpressLayers: 3,        // æ¯æ¬¡å–·å‘å åŠ å¤šå°‘å±‚ï¼ˆé€’å¢ç¼©æ”¾ï¼‰
        layerScaleStep: 0.18       // ç›¸é‚»å±‚ç¼©æ”¾å¢é‡ï¼ˆç›¸å¯¹ scaleFactorï¼‰
      }
    };

    /** ================= ç”»å¸ƒ & DPR é€‚é… ================= */
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

    function fitCanvas() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2.5));
      const rect = canvas.getBoundingClientRect();
      const w = Math.floor(rect.width);
      const h = Math.floor(rect.height);
      canvas.width  = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // å­—ä½“åŸºå‡†ï¼šçŸ­è¾¹ 3%ï¼ˆâ€œå‡åŠå­—å·â€ï¼‰
      const basePx = Math.round(Math.max(28, Math.min(50, Math.min(w, h) * 0.03)));
      return { w, h, dpr, basePx };
    }
    let view = fitCanvas();
    window.addEventListener('resize', () => {
      view = fitCanvas(); buildTextAtlases();
      sprites.forEach(s=>s.reset(view.w, view.h, true));
      buildHeartSprites();
      buildHeartFields();
    }, { passive: true });

    /** ================= å·¥å…·å‡½æ•° ================= */
    const rnd=(a,b)=>Math.random()*(b-a)+a;
    const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));

    /** ================= å°çˆ±å¿ƒè´´å›¾ ================= */
    function makeHeartSprite(sizePx, color) {
      const s = Math.max(6, sizePx|0);
      const off = document.createElement('canvas');
      off.width = off.height = s;
      const c = off.getContext('2d');
      c.fillStyle = color;
      c.translate(s/2, s/2);
      const r = s/2;
      c.beginPath();
      c.moveTo(0, r*0.45);
      c.bezierCurveTo(r, r*1.1,  r*1.6, -r*0.2,  0, -r*0.55);
      c.bezierCurveTo(-r*1.6, -r*0.2, -r, r*1.1, 0, r*0.45);
      c.closePath();
      c.fill();
      return off;
    }

    let HEART_SPRITES = [];
    function buildHeartSprites() {
      HEART_SPRITES = [];
      for (const col of CONFIG.bigHeart.colors) {
        for (let sz = CONFIG.bigHeart.dotSizeMin; sz <= CONFIG.bigHeart.dotSizeMax; sz += 2) {
          HEART_SPRITES.push(makeHeartSprite(sz, col));
        }
      }
    }
    buildHeartSprites();

    /** ================= æ–‡æœ¬è´´å›¾ç¼“å­˜ï¼ˆatlasï¼‰ ================= */
    let TEXT_ATLASES = [];
    function buildTextAtlases() {
      TEXT_ATLASES = CONFIG.textScales.map(scale => {
        const fontPx = Math.round(view.basePx * scale);
        const tmp = document.createElement('canvas');
        const tctx = tmp.getContext('2d');
        const text = CONFIG.loverName;
        tctx.font = `${fontPx}px "Microsoft YaHei","Noto Sans CJK SC",sans-serif`;
        const m = tctx.measureText(text);
        tmp.width = Math.ceil(m.width) + 8;
        tmp.height = Math.ceil(fontPx * 1.2);
        const octx = tmp.getContext('2d');
        octx.font = `${fontPx}px "Microsoft YaHei","Noto Sans CJK SC",sans-serif`;
        octx.textBaseline = 'middle';
        octx.fillStyle = CONFIG.textColor;
        octx.fillText(text, 0, tmp.height / 2);
        return { canvas: tmp, w: tmp.width, h: tmp.height, fontPx };
      });
    }
    buildTextAtlases();

    /** ================= å¿ƒå½¢å‚æ•°æ–¹ç¨‹ï¼ˆæœä¸Šï¼‰ ================= */
    function heartPoint(t, scale) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x: x * scale, y: -y * scale };
    }

    /** ================= ä¸‰å±‚å¿ƒå½¢â€œç‚¹åœºâ€ ================= */
    let HEART_FIELDS = []; // [ [dots...], [dots...], [dots...] ]
    function buildLayerField(count) {
      const arr = [];
      for (let i=0;i<count;i++){
        const t = Math.random() * Math.PI * 2;
        const inner = rnd(0.55, 1.0);
        const jitter = rnd(-1.2, 1.2);
        const sprite = HEART_SPRITES[(Math.random()*HEART_SPRITES.length)|0];
        const phase = Math.random() * Math.PI * 2;
        arr.push({ t, inner, jitter, sprite, phase, rot: rnd(-0.35,0.35) });
      }
      return arr;
    }
    function buildHeartFields() {
      HEART_FIELDS = CONFIG.bigHeart.layers.map(l => buildLayerField(l.count));
    }
    buildHeartFields();

    /** ================= é£˜åŠ¨æ–‡å­—ï¼ˆé˜²é‡å ï¼‰ ================= */
    class Sprite {
      constructor(w,h){ this.reset(w,h,true); }
      reset(w,h,randomY=false){
        const idx = (Math.random()*TEXT_ATLASES.length)|0;
        this.atlasIdx = idx;
        const a = TEXT_ATLASES[idx];
        this.x = rnd(0, w);
        this.y = randomY ? rnd(0, h) : -a.h;
        this.vx = rnd(-CONFIG.speed*0.6, CONFIG.speed*0.6);
        this.vy = rnd(CONFIG.speed*0.6,  CONFIG.speed*1.0);
        this.rot = rnd(-0.08, 0.08);
        this.spin = rnd(-CONFIG.rotMax, CONFIG.rotMax);
        this.alpha = rnd(CONFIG.alphaRange[0], CONFIG.alphaRange[1]);
      }
      bounds(){ const a = TEXT_ATLASES[this.atlasIdx]; return { w:a.w, h:a.h }; }
      update(dt,w,h){
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.rot += this.spin * dt;
        if (this.y > h + 40 || this.x < -400 || this.x > w + 400) {
          this.reset(w, h, false);
        }
      }
      draw(ctx){
        const a = TEXT_ATLASES[this.atlasIdx];
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);
        ctx.drawImage(a.canvas, -a.w/2, -a.h/2);
        ctx.restore();
      }
    }

    function applySeparation(sprites, w, h, blockCX, blockCY, blockR) {
      const k = 0.015;
      // 1) äº’ç›¸è½»æ¨
      for (let i=0;i<sprites.length;i++){
        const si = sprites[i], bi = si.bounds();
        for (let j=i+1;j<sprites.length;j++){
          const sj = sprites[j], bj = sj.bounds();
          const dx = sj.x - si.x, dy = sj.y - si.y;
          const dist = Math.hypot(dx,dy)||0.0001;
          const minD = (bi.h*CONFIG.minDistanceFactor + bj.h*CONFIG.minDistanceFactor)*0.5;
          if (dist < minD){
            const overlap = (minD - dist);
            const ux = dx/dist, uy = dy/dist;
            si.x -= ux * overlap * k; si.y -= uy * overlap * k;
            sj.x += ux * overlap * k; sj.y += uy * overlap * k;
          }
        }
      }
      // 2) å¯¹ä¸­å¿ƒä¸‰å±‚å¿ƒå½¢çš„åŒ…å›´åœˆç•™ç©º
      for (const s of sprites){
        const dx = s.x - blockCX, dy = s.y - blockCY;
        const d = Math.hypot(dx, dy) || 0.0001;
        if (d < blockR){
          const ux = dx / d, uy = dy / d;
          const offset = (blockR - d) * 0.08;
          s.x += ux * offset; s.y += uy * offset;
        }
      }
      // 3) è½»åº¦è¾¹ç•Œé™åˆ¶
      for (const s of sprites){
        s.x = clamp(s.x, -300, w+300);
        s.y = clamp(s.y, -300, h+300);
      }
    }

    /** ================= ç‚¹å‡»/è§¦æ‘¸ï¼šå¿ƒå½¢çˆ†è£‚ï¼ˆå•æ¬¡ & é•¿æŒ‰è¿å‘ï¼‰ ================= */
    let bursts = []; // {x,y,vx,vy,life,maxLife,rot,sprite}
    let isPressing = false;
    let pressTimer = null;
    let lastPos = { x: 0, y: 0 };
    let loopPhase = 0; // ç”¨äºè¿å‘æ—¶çš„å±‚çº§ç›¸ä½å˜åŒ–

    function spawnBurstHeart(x, y, layerScaleMul = 1, phaseBias = 0) {
      const base = Math.min(view.w, view.h) * CONFIG.burst.scaleFactor * layerScaleMul;
      for (let i = 0; i < CONFIG.burst.count; i++) {
        const t = Math.random() * Math.PI * 2 + phaseBias; // åŠ ç›¸ä½åç§»ï¼Œè®©æ¯è½®æœ‰ç»†å¾®åŒºåˆ«
        const pt = heartPoint(t, base);
        const px = x + pt.x + rnd(-CONFIG.burst.jitter, CONFIG.burst.jitter);
        const py = y + pt.y + rnd(-CONFIG.burst.jitter, CONFIG.burst.jitter);

        // åˆ‡å‘ä¸å¾„å‘çš„æ··åˆï¼Œåƒæ˜¯æ²¿å¿ƒå½¢ç‚¸å¼€
        const dir = Math.atan2(pt.y, pt.x) + Math.PI/2;
        const radial = Math.atan2(pt.y, pt.x);
        const mix = 0.55;
        const ang = dir * mix + radial * (1 - mix);

        const sp = rnd(CONFIG.burst.velocity * 0.85, CONFIG.burst.velocity * 1.15);
        const sprite = HEART_SPRITES[(Math.random()*HEART_SPRITES.length)|0];

        bursts.push({
          x: px, y: py,
          vx: Math.cos(ang) * sp,
          vy: Math.sin(ang) * sp,
          life: rnd(CONFIG.burst.life*0.8, CONFIG.burst.life*1.2),
          maxLife: CONFIG.burst.life,
          rot: rnd(-0.7, 0.7),
          sprite
        });
      }
    }

    // é•¿æŒ‰ä¸€è½®ï¼šå åŠ å¤šå±‚ä¸åŒåŠå¾„çš„å°å¿ƒå½¢
    function spawnBurstHeartMulti(x, y) {
      loopPhase += 0.9; // è®©æ¯è½®æœ‰æ—‹è½¬/ç›¸ä½å˜åŒ–
      for (let i = 0; i < CONFIG.burst.longpressLayers; i++) {
        const mul = 1 + i * CONFIG.burst.layerScaleStep;     // é€å±‚å˜å¤§
        const bias = loopPhase + i * Math.PI * 0.33;         // åˆ†å±‚ç›¸ä½é”™å¼€
        spawnBurstHeart(x, y, mul, bias);
      }
    }

    function startPressLoop() {
      if (pressTimer) return;
      pressTimer = setInterval(() => {
        spawnBurstHeartMulti(lastPos.x, lastPos.y);
      }, CONFIG.burst.longpressIntervalMs);
    }
    function stopPressLoop() {
      if (pressTimer) { clearInterval(pressTimer); pressTimer = null; }
    }

    // äº‹ä»¶ï¼šç‚¹å‡»/è§¦æ‘¸
    function canvasXY(e){
      const r=canvas.getBoundingClientRect();
      let x,y; if(e.touches&&e.touches[0]){ x=e.touches[0].clientX-r.left; y=e.touches[0].clientY-r.top; }
      else { x=e.clientX-r.left; y=e.clientY-r.top; }
      return {x,y};
    }

    // å•æ¬¡ç‚¹å‡»
    function handleSingleBurst(e){
      const {x,y} = canvasXY(e);
      spawnBurstHeart(x,y);
    }

    // é•¿æŒ‰é€»è¾‘ï¼ˆé¼ æ ‡ï¼‰
    canvas.addEventListener('mousedown', (e)=> {
      isPressing = true;
      lastPos = canvasXY(e);
      // ç«‹å³æ¥ä¸€å‘ï¼Œæ‰‹æ„Ÿæ›´å¥½
      spawnBurstHeartMulti(lastPos.x, lastPos.y);
      startPressLoop();
    }, { passive: true });
    window.addEventListener('mousemove', (e)=> {
      if (!isPressing) return;
      lastPos = canvasXY(e);
    }, { passive: true });
    window.addEventListener('mouseup', ()=> { isPressing = false; stopPressLoop(); }, { passive: true });
    canvas.addEventListener('mouseleave', ()=> { isPressing = false; stopPressLoop(); }, { passive: true });

    // è§¦æ‘¸ï¼štap å•å‘ + é•¿æŒ‰è¿å‘ï¼ˆè·Ÿæ‰‹ï¼‰
    let touchPressTimeout = null;
    canvas.addEventListener('touchstart', (e)=> {
      lastPos = canvasXY(e);
      isPressing = true;
      // ç«‹å³æ¥ä¸€å‘
      spawnBurstHeartMulti(lastPos.x, lastPos.y);
      startPressLoop();
      // è‹¥ä½ æƒ³â€œçŸ­ç‚¹ä¸ºå•å‘ã€é•¿æŒ‰æ‰è¿å‘â€ï¼Œå¯ä½¿ç”¨å»¶è¿Ÿï¼š
      // touchPressTimeout = setTimeout(startPressLoop, 150);
    }, { passive: true });
    canvas.addEventListener('touchmove', (e)=> {
      if (!isPressing) return;
      lastPos = canvasXY(e);
    }, { passive: true });
    canvas.addEventListener('touchend', ()=> {
      isPressing = false;
      stopPressLoop();
      if (touchPressTimeout) { clearTimeout(touchPressTimeout); touchPressTimeout = null; }
    }, { passive: true });
    canvas.addEventListener('touchcancel', ()=> {
      isPressing = false;
      stopPressLoop();
      if (touchPressTimeout) { clearTimeout(touchPressTimeout); touchPressTimeout = null; }
    }, { passive: true });

    // ä»ä¿ç•™â€œç‚¹å‡»ä¸€æ¬¡ç«‹åˆ»å•å‘â€çš„ä½“éªŒï¼ˆä¸æƒ³ä¿ç•™å¯åˆ é™¤ä¸‹é¢è¿™è¡Œï¼‰
    canvas.addEventListener('click', handleSingleBurst, { passive: true });

    /** ================= å°çˆ±å¿ƒçˆ†è£‚çš„æ›´æ–°/ç»˜åˆ¶ ================= */
    function updateBursts(dt) {
      const floatUp = -0.35; // è½»å¾®å‘ä¸Šæ¼‚
      for (let i=bursts.length-1;i>=0;i--){
        const b = bursts[i];
        b.life -= dt;
        if (b.life <= 0) { bursts.splice(i,1); continue; }
        b.vy += floatUp * dt; // ä¸Šæµ®
        b.x  += b.vx * dt;
        b.y  += b.vy * dt;
      }
    }
    function drawBursts(ctx){
      for (const b of bursts){
        const a = clamp(b.life / b.maxLife, 0, 1);
        ctx.save();
        ctx.globalAlpha = a * 0.95;
        ctx.translate(b.x, b.y);
        ctx.rotate(b.rot);
        ctx.drawImage(b.sprite, -b.sprite.width/2, -b.sprite.height/2);
        ctx.restore();
      }
    }

    /** ================= åˆå§‹åŒ–ï¼šæ–‡å­—ç²¾çµ ================= */
    let sprites = Array.from({ length: CONFIG.textCount }, ()=>new Sprite(view.w, view.h));

    /** ================= ä¸»å¾ªç¯ï¼ˆå• RAFï¼‰ ================= */
    let last = performance.now();
    function frame(now){
      const dt = clamp((now-last)/1000, 0, 0.05); last = now;
      const w=view.w, h=view.h;
      ctx.fillStyle = CONFIG.bgColor; ctx.fillRect(0,0,w,h);

      const t = now / 1000;
      const cx = w/2, cy = h/2;

      // â€”â€” å¤§å°äº¤æ›¿çš„å¿ƒè·³ â€”â€” //
      const beatPhase = t * Math.PI * 2 * CONFIG.bigHeart.freq; // ä¸»å¿ƒè·³ç›¸ä½
      const mod = 0.5 * (1 + Math.sin(beatPhase * 0.5));        // 0..1
      const amp = CONFIG.bigHeart.ampLo + (CONFIG.bigHeart.ampHi - CONFIG.bigHeart.ampLo) * mod;
      const baseScale = Math.min(w,h) * CONFIG.bigHeart.baseScaleFactor;
      const heartScaleBase = baseScale * (1 + amp * Math.sin(beatPhase));

      // â€”â€” ä¸‰å±‚å°çˆ±å¿ƒæ‹¼å›¾ â€”â€” //
      for (let li = 0; li < CONFIG.bigHeart.layers.length; li++) {
        const layer = CONFIG.bigHeart.layers[li];
        const dots = HEART_FIELDS[li];
        const layerScale = heartScaleBase * layer.scale;
        ctx.globalAlpha = layer.alpha;
        for (const dot of dots) {
          const edge = heartPoint(dot.t, layerScale);
          const px = cx + edge.x * dot.inner + dot.jitter;
          const py = cy + edge.y * dot.inner + dot.jitter;
          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(dot.rot + Math.sin(t + dot.phase) * 0.04);
          ctx.drawImage(dot.sprite, -dot.sprite.width/2, -dot.sprite.height/2);
          ctx.restore();
        }
      }
      ctx.globalAlpha = 1;

      // â€”â€” å¿ƒå½¢çˆ†è£‚ï¼ˆå•å‘/è¿å‘ï¼‰ â€”â€” //
      updateBursts(dt);
      drawBursts(ctx);

      // â€”â€” é£˜åŠ¨æ–‡å­—ï¼ˆæ›´æ–°â†’åˆ†ç¦»â†’ç»˜åˆ¶ï¼‰ï¼Œå¯¹ä¸­å¿ƒç•™ç©º â€”â€” //
      const blockR = heartScaleBase * Math.max(...CONFIG.bigHeart.layers.map(l => l.scale)) * 19;
      for (const s of sprites) s.update(dt,w,h);
      applySeparation(sprites, w, h, cx, cy, blockR);
      for (const s of sprites) s.draw(ctx);

      requestAnimationFrame(frame);
    }
    requestAnimationFrame(t=>{ last=t; frame(t); });
  })();
  </script>
</body>
</html>
